<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EID Auto-Detection Cropper</title> 
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load jsPDF library for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Custom styles for modern aesthetics and canvas appearance */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }

        .main-card {
            background-color: #ffffff;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
        }

        .cropper-container {
            position: relative;
            cursor: crosshair;
            margin-bottom: 1rem;
            background-color: #fafafa;
            border: 2px dashed #9ca3af;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            overflow: hidden;
            border-radius: 0.75rem;
        }

        .canvas-output {
            border: 3px solid #10b981; /* Green border for success */
            background-color: #fff;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            height: auto;
            transition: all 0.3s ease-in-out;
        }

        /* Styling for the range slider for rotation */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 0 2px 0 #5a66c8;
            margin-top: -6px; /* Adjusting the thumb for cross-browser consistency */
        }
        input[type=range]:focus {
            outline: none;
        }
    </style>
</head>
<body class="p-4 md:p-10">
    <div class="max-w-7xl mx-auto main-card rounded-3xl p-6 md:p-12">
        
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-sky-500">
                EID Auto-Crop & High-DPI Print Tool
            </h1>
            <p id="target-output-display" class="text-gray-600 mt-3 text-lg font-medium">Target Output: 3.2" W x 2.2" H (600 DPI) on A4 Page</p>
        </header>

        <!-- Dynamic Dimension Control Panel -->
        <div class="mb-10 p-6 bg-indigo-50 border-l-8 border-indigo-500 rounded-xl shadow-inner">
            <h2 class="text-2xl font-bold text-indigo-800 mb-5 text-center">Set Lamination Size (Inches)</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-6 max-w-md mx-auto">
                <div>
                    <label for="target-width-input" class="block text-sm font-semibold text-gray-700 mb-1">Width (Inches):</label>
                    <input type="number" id="target-width-input" value="3.2" min="0.1" step="0.1" 
                           onchange="updateTargetDimensions()" 
                           class="w-full rounded-lg border-gray-300 shadow-md p-3 text-center text-xl font-extrabold text-indigo-700 focus:ring-sky-500 focus:border-sky-500 transition duration-150">
                </div>
                <div>
                    <label for="target-height-input" class="block text-sm font-semibold text-gray-700 mb-1">Height (Inches):</label>
                    <input type="number" id="target-height-input" value="2.2" min="0.1" step="0.1" 
                           onchange="updateTargetDimensions()" 
                           class="w-full rounded-lg border-gray-300 shadow-md p-3 text-center text-xl font-extrabold text-indigo-700 focus:ring-sky-500 focus:border-sky-500 transition duration-150">
                </div>
            </div>
            <p class="text-sm text-indigo-700 mt-4 text-center italic">The resulting aspect ratio determines the automatic crop.</p>
        </div>
        
        <main class="grid grid-cols-1 lg:grid-cols-2 gap-10">
            <!-- Photo 1 Area -->
            <section id="photo1-section" class="bg-gray-50 p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold text-gray-800 mb-5 border-b-2 border-indigo-200 pb-3">EID Front Side</h2>
                <input type="file" id="file1" accept="image/*" onchange="handleFileSelect(event, 1)">
                <label for="file1" class="file-label inline-block w-full text-center py-3 px-6 bg-gradient-to-r from-indigo-500 to-blue-600 text-white font-bold text-lg rounded-xl hover:from-indigo-600 hover:to-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition duration-150">
                    Upload Photo 1
                </label>

                <!-- Source Image Preview & Cropper -->
                <div class="mt-6">
                    <h3 class="font-semibold text-gray-700 mb-2">Source Image (View & Rotate)</h3>
                    <div class="cropper-container">
                        <canvas id="canvas-source-1" class="w-full h-full object-contain"></canvas>
                    </div>
                </div>

                <!-- Rotation Controls -->
                <div class="p-4 bg-white rounded-lg shadow-md mb-6">
                    <label for="rotation-slider-1" class="block text-sm font-medium text-gray-700 mb-2 flex justify-between items-center">
                        Rotate Image: <span id="rotation-value-1" class="font-bold text-indigo-600">0.0°</span>
                    </label>
                    <input type="range" id="rotation-slider-1" min="-180" max="180" value="0" step="0.1" 
                               oninput="handleRotationSlider(1, this.value)" 
                               class="w-full h-2 bg-indigo-200 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Auto-Detect Button -->
                <button onclick="autoDetectAndProcess(1)" class="w-full py-3 bg-gradient-to-r from-green-500 to-teal-600 text-white font-bold rounded-xl hover:from-green-600 hover:to-teal-700 transition shadow-lg transform hover:scale-[1.01]">
                    Auto Detect & Center Crop (<span id="btn-size-display-1">3.2" x 2.2" @ 600 DPI</span>)
                </button>
                
                <!-- Manual Override (Collapsible) -->
                <details class="mt-4 p-3 border border-gray-300 rounded-lg bg-white shadow-sm">
                    <summary class="font-semibold text-gray-700 cursor-pointer">Manual Fine-Tuning (Override Auto-Detect)</summary>
                    <div id="crop-settings-1" class="pt-3">
                        <p class="text-sm text-gray-600 mb-3">Adjust these pixels to manually define the ID boundaries if the auto-detect fails. Then click the Auto Detect button again to process.</p>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <input type="number" id="crop-x-1" placeholder="X Start (px)" class="p-2 border rounded focus:ring-blue-400" value="0" onchange="updateCropFromInput(1)">
                            <input type="number" id="crop-y-1" placeholder="Y Start (px)" class="p-2 border rounded focus:ring-blue-400" value="0" onchange="updateCropFromInput(1)">
                            <input type="number" id="crop-w-1" placeholder="Crop Width (px)" class="p-2 border rounded focus:ring-blue-400" onchange="updateCropFromInput(1)">
                            <input type="number" id="crop-h-1" placeholder="Crop Height (px)" class="p-2 border rounded focus:ring-blue-400" onchange="updateCropFromInput(1)">
                        </div>
                    </div>
                </details>


                <!-- Processed Output -->
                <div class="mt-8">
                    <h3 class="font-semibold text-gray-700 mb-2">Final DPI Output: <span id="size-display-1" class="text-green-600"></span></h3>
                    <canvas id="canvas-output-1" class="canvas-output mx-auto" style="display: none;"></canvas>
                    <p id="status-1" class="text-sm text-gray-500 mt-3 font-medium"></p>
                </div>
            </section>

            <!-- Photo 2 Area -->
            <section id="photo2-section" class="bg-gray-50 p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold text-gray-800 mb-5 border-b-2 border-indigo-200 pb-3">EID Backside</h2>
                <input type="file" id="file2" accept="image/*" onchange="handleFileSelect(event, 2)">
                <label for="file2" class="file-label inline-block w-full text-center py-3 px-6 bg-gradient-to-r from-indigo-500 to-blue-600 text-white font-bold text-lg rounded-xl hover:from-indigo-600 hover:to-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition duration-150">
                    Upload Photo 2
                </label>

                <!-- Source Image Preview & Cropper -->
                <div class="mt-6">
                    <h3 class="font-semibold text-gray-700 mb-2">Source Image (View & Rotate)</h3>
                    <div class="cropper-container">
                        <canvas id="canvas-source-2" class="w-full h-full object-contain"></canvas>
                    </div>
                </div>

                <!-- Rotation Controls -->
                <div class="p-4 bg-white rounded-lg shadow-md mb-6">
                    <label for="rotation-slider-2" class="block text-sm font-medium text-gray-700 mb-2 flex justify-between items-center">
                        Rotate Image: <span id="rotation-value-2" class="font-bold text-indigo-600">0.0°</span>
                    </label>
                    <input type="range" id="rotation-slider-2" min="-180" max="180" value="0" step="0.1" 
                               oninput="handleRotationSlider(2, this.value)" 
                               class="w-full h-2 bg-indigo-200 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Auto-Detect Button -->
                <button onclick="autoDetectAndProcess(2)" class="w-full py-3 bg-gradient-to-r from-green-500 to-teal-600 text-white font-bold rounded-xl hover:from-green-600 hover:to-teal-700 transition shadow-lg transform hover:scale-[1.01]">
                    Auto Detect & Center Crop (<span id="btn-size-display-2">3.2" x 2.2" @ 600 DPI</span>)
                </button>
                
                <!-- Manual Override (Collapsible) -->
                <details class="mt-4 p-3 border border-gray-300 rounded-lg bg-white shadow-sm">
                    <summary class="font-semibold text-gray-700 cursor-pointer">Manual Fine-Tuning (Override Auto-Detect)</summary>
                    <div id="crop-settings-2" class="pt-3">
                        <p class="text-sm text-gray-600 mb-3">Adjust these pixels to manually define the ID boundaries if the auto-detect fails. Then click the Auto Detect button again to process.</p>
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <input type="number" id="crop-x-2" placeholder="X Start (px)" class="p-2 border rounded focus:ring-blue-400" value="0" onchange="updateCropFromInput(2)">
                            <input type="number" id="crop-y-2" placeholder="Y Start (px)" class="p-2 border rounded focus:ring-blue-400" value="0" onchange="updateCropFromInput(2)">
                            <input type="number" id="crop-w-2" placeholder="Crop Width (px)" class="p-2 border rounded focus:ring-blue-400" onchange="updateCropFromInput(2)">
                            <input type="number" id="crop-h-2" placeholder="Crop Height (px)" class="p-2 border rounded focus:ring-blue-400" onchange="updateCropFromInput(2)">
                        </div>
                    </div>
                </details>


                <!-- Processed Output -->
                <div class="mt-8">
                    <h3 class="font-semibold text-gray-700 mb-2">Final DPI Output: <span id="size-display-2" class="text-green-600"></span></h3>
                    <canvas id="canvas-output-2" class="canvas-output mx-auto" style="display: none;"></canvas>
                    <p id="status-2" class="text-sm text-gray-500 mt-3 font-medium"></p>
                </div>
            </section>
        </main>

        <!-- Global Output Controls -->
        <div class="mt-12 pt-8 border-t-2 border-gray-200 text-center">
            <h2 class="text-3xl font-extrabold text-gray-800 mb-5">Download Print-Ready PDF</h2>
            <p id="global-status" class="text-red-600 mb-6 font-semibold text-lg"></p>
            <button onclick="generatePDF()" class="py-4 px-10 bg-gradient-to-r from-emerald-500 to-green-600 text-white font-extrabold rounded-full text-xl hover:from-emerald-600 hover:to-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition duration-150 shadow-2xl transform hover:scale-105">
                Generate A4 PDF (600 DPI)
            </button>
        </div>
    </div>
    
    <script>
        // Global storage for original images and configuration
        const images = {
            1: { img: null, processed: false, rotation: 0 },
            2: { img: null, processed: false, rotation: 0 }
        };

        // --- CORE DIMENSION CONFIGURATION ---
        const DPI = 600; 
        const A4_WIDTH_MM = 210;
        const A4_HEIGHT_MM = 297;
        const BACKGROUND_TOLERANCE = 40; // Max difference for a pixel component to be considered background
        
        // Dynamic calculated size variables
        let TARGET_WIDTH_IN, TARGET_HEIGHT_IN;
        let TARGET_WIDTH_PX, TARGET_HEIGHT_PX;
        let TARGET_WIDTH_MM, TARGET_HEIGHT_MM;
        let TARGET_ASPECT_RATIO;
        
        /**
         * Reads the input fields, recalculates all dependent size variables, and updates the UI labels.
         */
        function updateTargetDimensions() {
            const widthInput = document.getElementById('target-width-input');
            const heightInput = document.getElementById('target-height-input');

            // 1. Read and validate values
            let width = parseFloat(widthInput.value);
            let height = parseFloat(heightInput.value);
            
            // Default and minimum check
            if (isNaN(width) || width <= 0.1) width = 3.2;
            if (isNaN(height) || height <= 0.1) height = 2.2;
            
            widthInput.value = width.toFixed(1);
            heightInput.value = height.toFixed(1);

            // 2. Update global variables
            TARGET_WIDTH_IN = width;
            TARGET_HEIGHT_IN = height;

            // 3. Recalculate dependent values
            TARGET_WIDTH_PX = Math.round(TARGET_WIDTH_IN * DPI);
            TARGET_HEIGHT_PX = Math.round(TARGET_HEIGHT_IN * DPI);
            
            TARGET_WIDTH_MM = TARGET_WIDTH_IN * 25.4;
            TARGET_HEIGHT_MM = TARGET_HEIGHT_IN * 25.4;
            
            TARGET_ASPECT_RATIO = TARGET_WIDTH_IN / TARGET_HEIGHT_IN;

            // 4. Update UI labels
            const displayString = `${TARGET_WIDTH_IN.toFixed(1)}" W x ${TARGET_HEIGHT_IN.toFixed(1)}" H (${TARGET_WIDTH_PX} x ${TARGET_HEIGHT_PX} px @ ${DPI} DPI)`;
            const btnDisplayString = `${TARGET_WIDTH_IN.toFixed(1)}" x ${TARGET_HEIGHT_IN.toFixed(1)}" @ ${DPI} DPI`;
            
            document.getElementById('target-output-display').textContent = `Target Output: ${displayString} on A4 Page`;
            
            document.getElementById('size-display-1').textContent = displayString;
            document.getElementById('size-display-2').textContent = displayString;
            document.getElementById('btn-size-display-1').textContent = btnDisplayString;
            document.getElementById('btn-size-display-2').textContent = btnDisplayString;
            
            images[1].processed = false;
            images[2].processed = false;
        }
        
        window.onload = updateTargetDimensions;


        /**
         * Checks if a pixel color is close to white (background), used for simple edge detection.
         * @param {number} r Red channel value (0-255).
         * @param {number} g Green channel value (0-255).
         * @param {number} b Blue channel value (0-255).
         * @returns {boolean} True if the pixel is considered background.
         */
        function isBackground(r, g, b) {
            // Assume background is close to white (255, 255, 255)
            return (r > 255 - BACKGROUND_TOLERANCE && 
                    g > 255 - BACKGROUND_TOLERANCE && 
                    b > 255 - BACKGROUND_TOLERANCE);
        }

        /**
         * Core auto-detection logic: finds the tightest bounding box around non-background pixels.
         * @param {HTMLCanvasElement} canvas The canvas containing the rotated image.
         * @returns {{x: number, y: number, w: number, h: number} | null} The detected bounding box.
         */
        function autoDetectCorners(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let minX = canvas.width, minY = canvas.height;
            let maxX = 0, maxY = 0;
            let foundContent = false;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    if (!isBackground(r, g, b)) {
                        foundContent = true;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            if (!foundContent) {
                return null;
            }

            // Add a small safety margin (e.g., 5 pixels)
            const margin = 5; 
            minX = Math.max(0, minX - margin);
            minY = Math.max(0, minY - margin);
            maxX = Math.min(canvas.width, maxX + margin);
            maxY = Math.min(canvas.height, maxY + margin);

            const w = maxX - minX;
            const h = maxY - minY;

            return { x: minX, y: minY, w: w, h: h };
        }

        /**
         * Redraws the source canvas, applying the current rotation and drawing the crop overlay.
         * @param {number} id Photo ID (1 or 2).
         */
        function drawSourceCanvas(id) {
            const imgData = images[id];
            const img = imgData.img;
            if (!img) return;

            const canvas = document.getElementById(`canvas-source-${id}`);
            const ctx = canvas.getContext('2d');
            const rotation = imgData.rotation;

            const OW = img.naturalWidth;
            const OH = img.naturalHeight;

            canvas.width = OW;
            canvas.height = OH;

            ctx.clearRect(0, 0, OW, OH);
            
            // --- 1. Apply Image Transformation for Display ---
            ctx.save();
            ctx.translate(OW / 2, OH / 2);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.drawImage(img, -OW / 2, -OH / 2, OW, OH);
            ctx.restore(); 

            // --- 2. Draw Cropping Overlay if Manual/Detected Crop is Set ---
            const x = parseFloat(document.getElementById(`crop-x-${id}`).value) || 0;
            const y = parseFloat(document.getElementById(`crop-y-${id}`).value) || 0;
            const w = parseFloat(document.getElementById(`crop-w-${id}`).value) || 0;
            const h = parseFloat(document.getElementById(`crop-h-${id}`).value) || 0;
            
            if (w > 0 && h > 0) {
                ctx.strokeStyle = '#f97316'; // Orange border for crop area
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]); // Dashed line
                ctx.strokeRect(x, y, w, h);
                ctx.setLineDash([]);
            }
        }

        /**
         * Updates the crop rectangle based on manual input changes, then redraws.
         * @param {number} id Photo ID (1 or 2).
         */
        function updateCropFromInput(id) {
            if (!images[id].img) return;
            drawSourceCanvas(id);
        }


        /**
         * Handles file selection and initial image loading.
         * @param {Event} event The file input change event.
         * @param {number} id Photo ID (1 or 2).
         */
        function handleFileSelect(event, id) {
            const file = event.target.files[0];
            if (!file) return;

            images[id].processed = false;
            images[id].rotation = 0; 

            document.getElementById(`rotation-slider-${id}`).value = 0;
            document.getElementById(`rotation-value-${id}`).textContent = '0.0°';

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    images[id].img = img;
                    
                    // Initialize crop to the full image
                    document.getElementById(`crop-x-${id}`).value = 0;
                    document.getElementById(`crop-y-${id}`).value = 0;
                    document.getElementById(`crop-w-${id}`).value = img.naturalWidth;
                    document.getElementById(`crop-h-${id}`).value = img.naturalHeight;
                    
                    drawSourceCanvas(id);
                    document.getElementById(`status-${id}`).textContent = `Image loaded: ${img.naturalWidth} x ${img.naturalHeight} px. Adjust rotation if needed.`;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        /**
         * Handles the rotation slider input.
         * @param {number} id Photo ID (1 or 2).
         * @param {string} value The current rotation value in degrees.
         */
        function handleRotationSlider(id, value) {
            const degrees = parseFloat(value);
            images[id].rotation = degrees;
            document.getElementById(`rotation-value-${id}`).textContent = `${degrees.toFixed(1)}°`;
            drawSourceCanvas(id);
            document.getElementById(`status-${id}`).textContent = `Rotation set to ${degrees.toFixed(1)}°. Click 'Auto Detect' to process.`;
        }


        /**
         * Executes the auto-detection and processing workflow.
         * @param {number} id Photo ID (1 or 2).
         */
        function autoDetectAndProcess(id) {
            // Step 0: Ensure image is loaded
            const imgData = images[id];
            if (!imgData.img) {
                document.getElementById(`status-${id}`).textContent = 'Error: Please upload an image first.';
                return;
            }
            
            // 1. Create a rotated canvas for detection/cropping
            const rotatedCanvas = document.createElement('canvas');
            const OW = imgData.img.naturalWidth;
            const OH = imgData.img.naturalHeight;

            rotatedCanvas.width = OW;
            rotatedCanvas.height = OH;
            const rCtx = rotatedCanvas.getContext('2d');

            rCtx.save();
            rCtx.translate(OW / 2, OH / 2);
            rCtx.rotate(imgData.rotation * Math.PI / 180);
            rCtx.drawImage(imgData.img, -OW / 2, -OH / 2, OW, OH);
            rCtx.restore();

            // 2. Auto-Detect Corners (Bounding Box) on the Rotated Image
            let detectedCrop = autoDetectCorners(rotatedCanvas);
            let userCropX, userCropY, userCropW, userCropH;
            
            if (detectedCrop) {
                 // Use detected crop for processing and update manual inputs
                userCropX = detectedCrop.x;
                userCropY = detectedCrop.y;
                userCropW = detectedCrop.w;
                userCropH = detectedCrop.h;
                
                document.getElementById(`crop-x-${id}`).value = userCropX.toFixed(0);
                document.getElementById(`crop-y-${id}`).value = userCropY.toFixed(0);
                document.getElementById(`crop-w-${id}`).value = userCropW.toFixed(0);
                document.getElementById(`crop-h-${id}`).value = userCropH.toFixed(0);
                
                document.getElementById(`status-${id}`).textContent = `✅ Auto-detected boundaries. Proceeding with center crop...`;

            } else {
                // Fallback: use user input (or full image if inputs weren't changed)
                userCropX = parseFloat(document.getElementById(`crop-x-${id}`).value) || 0;
                userCropY = parseFloat(document.getElementById(`crop-y-${id}`).value) || 0;
                userCropW = parseFloat(document.getElementById(`crop-w-${id}`).value) || OW;
                userCropH = parseFloat(document.getElementById(`crop-h-${id}`).value) || OH;
                
                document.getElementById(`status-${id}`).textContent = `⚠️ Auto-detection failed or found no content. Using manual area: ${userCropW} x ${userCropH} px.`;
            }
            
            // Draw the final detected/manual crop on the source preview
            drawSourceCanvas(id);

            // 3. Calculate the fixed-ratio crop area centered within the detected area
            let finalCropW, finalCropH, finalCropX, finalCropY;
            
            if ((userCropW / userCropH) > TARGET_ASPECT_RATIO) {
                // Detected area is wider than needed -> Constrain by height
                finalCropH = userCropH;
                finalCropW = finalCropH * TARGET_ASPECT_RATIO;
            } else {
                // Detected area is taller than needed -> Constrain by width
                finalCropW = userCropW;
                finalCropH = finalCropW / TARGET_ASPECT_RATIO;
            }
            
            // Center the fixed-ratio crop within the detected/manual area
            finalCropX = userCropX + (userCropW - finalCropW) / 2;
            finalCropY = userCropY + (userCropH - finalCropH) / 2;

            // 4. Perform final Crop and Resize
            try {
                // Crop Canvas (cuts out the exact ratio area from the rotated image)
                const croppedCanvas = document.createElement('canvas');
                croppedCanvas.width = finalCropW; 
                croppedCanvas.height = finalCropH; 
                const cCtx = croppedCanvas.getContext('2d');

                cCtx.drawImage(
                    rotatedCanvas, 
                    finalCropX, finalCropY, finalCropW, finalCropH, // Source (rotated image)
                    0, 0, finalCropW, finalCropH // Destination
                );

                // Output Canvas (Resized to fixed DPI)
                const outputCanvas = document.getElementById(`canvas-output-${id}`);
                const targetW_px = TARGET_WIDTH_PX;
                const targetH_px = TARGET_HEIGHT_PX;
                
                outputCanvas.width = targetW_px;
                outputCanvas.height = targetH_px;
                outputCanvas.style.display = 'block';

                const outputCtx = outputCanvas.getContext('2d');
                outputCtx.drawImage(
                    croppedCanvas, 
                    0, 0, finalCropW, finalCropH, 
                    0, 0, targetW_px, targetH_px 
                );

                imgData.processed = true;
                document.getElementById(`status-${id}`).textContent = `✅ Finished! Cropped area: ${finalCropW.toFixed(0)} x ${finalCropH.toFixed(0)} px. Ready for PDF export.`;

            } catch (error) {
                console.error("Image processing failed:", error);
                document.getElementById(`status-${id}`).textContent = `Fatal Error: Image processing failed. ${error.message}`;
            }
        }

        /**
         * Generates an A4 PDF containing the two processed images.
         */
        function generatePDF() {
            updateTargetDimensions(); 
            document.getElementById('global-status').textContent = '';
            
            const isPhoto1Processed = images[1].processed;
            const isPhoto2Processed = images[2].processed;

            if (!isPhoto1Processed && !isPhoto2Processed) {
                document.getElementById('global-status').textContent = 'Error: Please auto-detect and process at least one photo before generating the PDF.';
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'p' });

            let xOffset, yOffset = 15; // 15mm top margin
            
            const targetWidthMM = TARGET_WIDTH_MM;
            const targetHeightMM = TARGET_HEIGHT_MM;

            for (let id = 1; id <= 2; id++) {
                if (images[id].processed) {
                    const canvas = document.getElementById(`canvas-output-${id}`);
                    
                    xOffset = (A4_WIDTH_MM - targetWidthMM) / 2;

                    // Page break if necessary
                    if (yOffset + targetHeightMM > A4_HEIGHT_MM - 15) { 
                        doc.addPage();
                        yOffset = 15;
                        xOffset = (A4_WIDTH_MM - targetWidthMM) / 2;
                    }

                    // Use JPEG at quality 1.0 (highest) to preserve 600 DPI fidelity
                    const imgData = canvas.toDataURL('image/jpeg', 1.0); 
                    
                    doc.addImage(imgData, 'JPEG', xOffset, yOffset, targetWidthMM, targetHeightMM);
                    yOffset += targetHeightMM + 10; // 10mm gap
                }
            }

            // Filename generation
            const sizeString = `${TARGET_WIDTH_IN.toFixed(1)}x${TARGET_HEIGHT_IN.toFixed(1)}`;
            const photoCount = (isPhoto1Processed && isPhoto2Processed) ? 'Both' : (isPhoto1Processed ? 'Front' : 'Back');
            const filename = `EID_AutoCrop_${photoCount}_${sizeString}in_${DPI}DPI.pdf`;
            
            doc.save(filename);
            
            document.getElementById('global-status').textContent = '✅ Print-ready PDF generated and downloaded!';
        }
    </script>
</body>
</html>